<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>Seymour: Live Programming with Details and the Big Picture</title>
    <link rel="stylesheet" href="tufte.css"/>
    <link rel="stylesheet" href="latex.css"/>
    <link rel="stylesheet" href="style.css"/>
    <meta name="viewport" content="width=device-width, initial-scale=1">
  </head>

  <body>
    <article>
      <h1 id="title">Seymour: Live Programming with Details and the Big Picture</h1>
      <p class="subtitle">Saketh Kasibatla and Alex Warth<br>
      HARC/Y Combinator Research</p>

      <section id="abstract">
        <blockquote><b>abstract goes here.</b> This project involves discovering how the American Revolution was remembered during the nineteenth century.  The goal is to show that the American Revolution was memorialized by the actions of the United States government during the 1800s. This has been done by examining events such as the Supreme Court cases of John Marshall and the Nullification Crisis. Upon examination of these events, it becomes clear that John Marshall and John Calhoun (creator of the Doctrine of Nullification) attempted to use the American Revolution to bolster their claims by citing speeches from Founding Fathers. Through showing that the American Revolution lives on in memory, this research highlights the importance of the revolution in shaping the actions of the United States government.</blockquote>
      </section>
      <section>
        <h2><span class="sectionNumber"></span> Introduction</h2>
      </section>
      <section>
        <h2><span class="sectionNumber"></span> Related Work</h2>

        <p>
        In 
        <span>&ldquo;Inventing on Principle,&rdquo;<label for="rw-iop" class="margin-toggle sidenote-number"></span><input type="checkbox" id="rw-iop" class="margin-toggle"><span class="sidenote"><a href="https://vimeo.com/36579366#t=16m25s" target="_blank">Bret Victor. &ldquo;Inventing on Principle&rdquo;</a> @16:25</span> Bret Victor showed a novel visualization of program execution that has heavily influenced the design of our micro visualization. This visualization shows changes to program state over time, with each change lined up with the line of code that produced it. To the best of our knowledge, no other program visualization maps effects to lines of code in this manner. Unlike our visualization, Bret’s does not include summaries of calls, and requires <span>interaction to show a call’s details<label for="rw-iop2" class="margin-toggle sidenote-number"></span><input type="checkbox" id="rw-iop2" class="margin-toggle"><span class="sidenote"><a href="https://vimeo.com/62049081#t=1m41s" target="_blank">Bret Victor. &ldquo;Showreel 2011&ndash;2012&rdquo;</a> @1:41</span>.
        </p>

        <p>
        <span>Light Table<label for="rw-lighttable" class="margin-toggle sidenote-number"></span><input type="checkbox" id="rw-lighttable" class="margin-toggle"><span class="sidenote"><a href="http://lighttable.com/" target="_blank">Chris Granger. &ldquo;Light Table&rdquo;</a></span> is an IDE that lets users see dynamic runtime state inline with source code. It uses ‘watches’ attached to expressions in the code to reveal their latest value as the program is executed. But, if a statement is run many times (e.g. as part of the body of a function), Light Table does not let the user select which context to show the value for. <span>YinYang<label for="rw-usable" class="margin-toggle sidenote-number"></span><input type="checkbox" id="rw-usable" class="margin-toggle"><span class="sidenote"><a href="http://dx.doi.org/10.1145/2509578.2509585" target="_blank">Sean McDirmid. &ldquo;Usable Live Programming&rdquo;</a></span> uses probes (similar to watches) to view expression values. It also uses ‘print’ statements to generate a log, whose outputs are tied to the context in which they are created. By clicking on an item in the log, the user can see probe values at the corresponding context. With Seymour, users can see the details of any context using the macro visualization. But, unlike Light Table and YinYang, Seymour shows all state changes in a scope by default, minimizing the interaction required to see program state.
        </p>

        <p>
        <span>DejaVu is a domain-specific IDE extension for &ldquo;interactive camera-based programs&rdquo;<label for="rw-dejavu" class="margin-toggle sidenote-number"></span><input type="checkbox" id="rw-dejavu" class="margin-toggle"><span class="sidenote"><a href="http://dx.doi.org/10.1145/2380116.2380142" target="_blank">Kato et. al. &ldquo;DejaVu: integrated support for developing interactive camera-based programs&rdquo;</a></span>. It features a low-level canvas view, which shows the values of variables at a ‘frame of interest’ and high-level timeline view, which shows variable values for many frames. These views complement each other in a similar manner to the micro and macro views in Seymour. However, while DejaVu is designed specifically for the domain of camera-based programs, and features visualizations tailored for displaying image data, Seymour’s visualizations are designed to explain the semantics of generic programs.
        </p>

        <p>
        <span>Online Python Tutor<label for="rw-pythontutor" class="margin-toggle sidenote-number"></span><input type="checkbox" id="rw-pythontutor" class="margin-toggle"><span class="sidenote">
          <a href="http://dx.doi.org/10.1145/2445196.2445368" target="_blank">Philip J. Guo. &ldquo;Online Python Tutor: Embeddable Web-Based Program Visualization for CS Education&rdquo;</a><br><br>
          <a href="http://pythontutor.com/live.html" target="_blank"> Philip J. Guo. &ldquo;Live Programming Mode - Python Tutor&rdquo;</a>
        </span>, a visualization tool for teaching beginner programmers, features a visualization that shows the program’s state at a single point in time. This includes the stack, the heap, and relations between objects. Objects are drawn as boxes, and are connected by arrows, as a professor might depict them in a classroom. We believe that this visualization is complementary to those included in Seymour, and that users would benefit from seeing a visualization that emphasizes different aspects of the program tied to our current views.
        </p>
      </section>
      <section>
        <h2><span class="sectionNumber"></span> The Programming Environment</h2>
        <p>
        Seymour’s programming environment consists of three different components, as shown in the screenshot below:
        </p>

        <figure id="screenshot1">
          <img class="block light-bg-protect" src="media/screenshot1.png"></img>
        </figure>

        <p>
        These are:
        </p>

        <ul>
          <li>the code editor (top left)</li>
          <li>the micro view, which can visualize any scope in detail </li>
          <li>the macro view, which serves as an overview of the whole program </li>
        </ul>

        <p>
        Together, these components help the user see and build a model of the inner workings of the program.
        </p>

        <h3>The Micro Visualization</h3>
        <p>The micro visualization focuses on telling the user a coherent story about the low level details of a program. 
        </p>

        <p>
        We show effects next to the lines that produce them, and changing the code for an effect changes the visualization live..
        </p>

        <figure id="video1" class="fullwidth">
          <div class="video-mask">
          <video class="block light-bg-protect" width="960" height="65" 
              poster="./media/micro_viz_example/1.poster.png" 
              preload="auto" muted="" data-video="0">
            <source src="./media/micro_viz_example/1.mp4" type="video/mp4">
          </video>
          </div>
        </figure>

        <!-- <figure id="env1">
          <label for="mn-change-code" class="margin-toggle">⊕</label><input type="checkbox" id="mn-change-code" class="margin-toggle"><span class="marginnote">the detail visualization updates when the code is edited</span>
          <div id="microVizContainer1"></div>
          <div id="errorDiv1"></div>
        </figure>  -->

        <p>
        Changes to program state are rendered next to the line where they happen, making it easy to connect the code and the micro visualization. We also render a blue dot for each subexpression in the program, allowing the user to see how a value was built up. Users can hover over these dots to see the value the corresponding subexpression returns.
        </p>

        <figure id="video2" class="fullwidth">
          <div class="video-mask">
          <video class="block light-bg-protect" width="960" height="107" 
              poster="./media/micro_viz_example/2.poster.png" 
              preload="auto" muted="" data-video="0">
            <source src="./media/micro_viz_example/2.mp4" type="video/mp4">
          </video>
          </div>
        </figure>

        <p>We show loops using several columns. Each column represents an iteration of the loop. The user can read through a single row to see how a values change over time, or they can read through a column to see what happened in a particular iteration.</p>

        <figure id="video4" class="fullwidth">
          <div class="video-mask">
          <video class="block light-bg-protect" width="960" height="132.5" 
              poster="./media/micro_viz_example/4.poster.png" 
              preload="auto" muted="" data-video="0">
            <source src="./media/micro_viz_example/4a.mp4" type="video/mp4">
          </video>
          </div>
        </figure>

        <p>
        Because we only show effects for code that is executed, it is easy to ‘follow the flow’* of the program over time.
        </p>

        <figure id="video5" class="fullwidth">
          <div class="video-mask">
          <video class="block light-bg-protect" width="960" height="170.5" 
              poster="./media/micro_viz_example/5.poster.png" 
              preload="auto" muted="" data-video="0">
            <source src="./media/micro_viz_example/5.mp4" type="video/mp4">
          </video>
          </div>
        </figure>

        <!-- <figure id="env2">
          <label for="mn-hover" class="margin-toggle">⊕</label><input type="checkbox" id="mn-hover" class="margin-toggle"><span class="marginnote">hovering over message sends (e.g. the loop, blue dots) highlights the code that produced them and shows their return value</span>
          <div id="microVizContainer2"></div>
          <div id="errorDiv2"></div>
        </figure>  -->

        <p>In addition to built in loop constructs, programmers often rely on control structures implemented in the language (e.g. map, filter, reduce). To the best of our knowledge, when working with these control structures, other similar visualizations do not support rendering these structures in the same manner as loops. Our visualization can detect and show ‘loopy’ code using multiple columns. This allows us to render many control structures, including those defined by the user, automatically.
        </p>
        
        <figure id="reduce">
          <label for="mn-emoji" class="margin-toggle">⊕</label><input type="checkbox" id="mn-emoji" class="margin-toggle"><span class="marginnote">We use emoji to identify different objects, instead of memory addresses or object IDs.</span>
          <img class="block light-bg-protect" src="media/reduce.png"></img>
        </figure>

        <p>
        While creating the micro visualization, we sought to help the user avoid simulating the program in their head. We show every state change, without interaction, so that the user does not have to simulate the program to select a portion of the state to show.
        </p>

        <p>
        When a method is called, in addition to producing a result, it can modify the program’s state. If these side effects are not shown, the user must fall back to mentally simulating the program. Consider the program below:
        </p>

        <figure id="summary">
          <img class="block light-bg-protect" src="media/summary.png"></img>
        </figure>

        <p>
        Because the call to f is preceded by a statement that increments a, and followed by a statement that decrements it, the user might expect a to be 5 at the end of the program. If we do not show that f sets a to 7, the user must resort to reading f’s source to figure out why a is not 5 at the end of the program. But, because we do show f’s side effects, at a glance, the user can confirm that a = 6 because f set a to 7 before it was decremented.
        </p>

        <p>
        For each message send, we summarize all side effects that are relevant to the execution after the send has completed. We show the last value of variables that are written multiple times, and hide the values of local variables that do not affect computation past the duration of the message send.
        </p>

        <figure id="summary-2">
          <img class="block light-bg-protect" src="media/summary-2.png"></img>
        </figure>

        <p>
        A message send's summary elides most of its implementation details in order to give the user 'just enough’ information to continue reading the story of the execution. But, if the user is interested in these details, we can show the story of any message send. In fact, we treat the program as a message send, and show its implementation details as we would those of any other message. For example, we can show the details of the call to add5 below.
        </p>

        <figure id="adder">
          <img class="block light-bg-protect" src="media/adder.png"></img>
        </figure>

        <p>
        When visualizing a message send, we also show all lexical scopes that the send has access to. Thus, all the information needed to calculate the send’s result is on screen, and the method only has access to the values it can ‘see’. In the program above, which visualizes the call to add5, we know the value of ‘this’ which the add5 call has access to at a glance.
        </p>

        <h3>The Macro Visualization</h3>

        <p>
        The micro view can visualize any single scope in the program. But, views of disconnected scopes are not enough to get a complete understanding of the program. Programmers need a low-level understanding of individual message sends, and a high level understanding of how these calls relate. 
        </p>

        <p>
        The macro visualization helps the user build this high-level understanding by
        </p>
        
        <ul>
          <li>showing overall patterns in the program</li>
          <li>provides a user interface for ‘focusing’ the micro visualization on different scopes</li>
          <li>serves as a steady frame to which the micro visualization can be related</li>
        </ul>

        <figure id="screenshot_fib_1">
          <img class="block light-bg-protect" src="media/fib_macro_viz.png"></img>
        </figure>

        <p>
        The visualization is a variation on the <span>icicle plot<label for="icicle" class="margin-toggle sidenote-number"></label></span><input type="checkbox" id="icicle" class="margin-toggle"><span class="sidenote"><a href="http://dx.doi.org/10.2307/2685881" target="_blank">Kruskal and Landwehr. &ldquo;Icicle Plots: Better Displays for Hierarchical Clustering&rdquo;</a></span>—a method for visualizing hierarchical data that makes it easy to see the ‘shape’ of a computation. Each method call is drawn as a rectangular node on screen. Time progresses from left to right, with clusters of calls acting as landmarks on the program’s timeline. All calls that a method makes are drawn below its node in the visualization. Calls that do not make any further calls (leaf calls) have fixed width, and all other sends are wide enough to contain all their children; calls with more subcalls are wider than those with fewer subcalls.
        </p>

        <p>
        <span>Chrome DevTools<label for="chrome-dev-tools" class="margin-toggle sidenote-number"></label></span><input type="checkbox" id="chrome-dev-tools" class="margin-toggle"><span class="sidenote">
          <a href="https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/reference" target="_blank">Google Developers. &ldquo;Performance Analysis Reference&rdquo;</a><br><br>
          <a href="http://blog.librato.com/posts/chrome-devtools" target="_blank">Librato Blog. &ldquo;Timeline Profiling with Chrome DevTools&rdquo;</a>
        </span> uses a similar icicle plot to provide an overview of all the calls that occur in a profile. But, instead of giving leaf calls a fixed width, all calls are scaled based on their running time.
        </p>

        <p>
        The visualization also serves as an interactive element to navigate between various scopes in the micro visualization. When the user clicks on a node in the macro visualization, we ‘focus’ the micro visualization on the scope associated with that node. This makes it easy for the user to switch between contexts, drill down, and gather detailed information about the program.
        </p>

        <figure id="fib_focus" class="fullwidth">
          <div class="video-mask">
          <video class="block light-bg-protect" width="960" height="455.5" 
              poster="./media/fib_focus.poster.png" 
              preload="auto" muted="" data-video="0">
            <source src="./media/fib_focus.mp4" type="video/mp4">
          </video>
          </div>
        </figure>

        <p>
        The macro visualization does not change as we focus on different scopes, and it shows every call in the program. This makes it useful as a ‘steady frame’ for navigating the program. But, without further help from the system, it is difficult to connect the time-oriented macro visualization with the code-oriented micro visualization. We help the user make this connection using parallel highlighting. When the user hovers over a node in the macro visualization, we highlight the definition and call site of the call in question. Similarly, when the user hovers over a call in the code, we highlight all nodes in the macro visualization that correspond to that call.
        </p>

        <figure id="fib_highlighting" class="fullwidth">
          <div class="video-mask">
          <video class="block light-bg-protect" width="960" height="455.5" 
              poster="./media/fib_highlighting.poster.png"
              preload="auto" muted="" data-video="0"> 
            <source src="./media/fib_highlighting.mp4" type="video/mp4">
          </video>
          </div>
        </figure>

      </section>
      <section>
        <h2><span class="sectionNumber"></span>Live Programming with Seymour</h2>
        <p>
        In this section, we will give the reader a feel for Seymour’s live editing experience.  Using several examples, we will show how the macro view, the micro view, and the ‘focus’ mechanic come together to let the user see the internals of a program as they write it.
        </p>

        <p>
        Each example consists of a video followed by commentary. Click the timestamp at the top of each paragraph to view the relevant portion of the video.
        </p>

        <h3>Number.fibonacci()</h3>

        <p>
        In the previous section, we saw how a user might interact with a fully written implementation of <code>Number.fibonacci()</code>. Here, we show how a we might implement the same program, with Seymour’s help. 
        </p>

        <figure id="video_fib" class="fullwidth">
          <div class="video-mask">
          <video class="block light-bg-protect" width="960" height="431.5" 
              poster="./media/fibonacci.poster.png" 
              preload="auto" muted="" data-video="0">
            <source src="./media/fib.mp4" type="video/mp4">
          </video>
          </div>
        </figure>

        <p>
        <a href="#" videoId="video_fib" class="timestamp" start="0:00" end="0:21"></a><br>
        We start by writing an empty method declaration and several calls to fibonacci. Each of these calls can be used as a concrete context in which the user can experiment with the algorithm. Because we can only take advantage of the micro visualization when there is a call for us to focus on, we are encouraged to consider a variety of examples that might help us understand different cases in the algorithm.
        </p>

        <p>
        <a href="#" videoId="video_fib" class="timestamp" start="0:21" end="0:39"></a><br>
        We focus on <code>1.fibonacci()</code>, and writes the algorithm’s base case. The micro visualization serves as a steady frame, showing method behavior as the code changes. As the user edits the method, and the program is re-executed, we <span>persistently focus on the same call<label for="managed-time" class="margin-toggle sidenote-number"></span><input type="checkbox" id="managed-time" class="margin-toggle"><span class="sidenote"><a href="http://dx.doi.org/10.1145/2661136.2661145" target="_blank">McDirmid and Edwards. &ldquo;Programming with Managed Time&rdquo;</a> @section 3</span>. This allows us to edit a method’s code without having to continually re-focus on the call of our choice.
        </p>

        <p>
        <a href="#" videoId="video_fib" class="timestamp" start="0:39" end="1:13"></a><br>
        We finish up by writing the recursive case. We can see the recursive structure of fibonacci emerge in the macro visualization, and the loop shows the correct answers for each call.
        </p>

        <h3>Array.toString()</h3>

        <p>
        In this example, we show how we can use Seymour to work with loops. We will implement <code>Array.toString()</code>, which must include the string representation of each of an array’s elements.
        </p>

        <figure id="video_arr_print" class="fullwidth">
          <div class="video-mask">
          <video class="block light-bg-protect" width="960" height="363" 
              poster="./media/array_print.poster.png" 
              preload="auto" muted="" data-video="0">
            <source src="./media/array_print/array_print.mp4" type="video/mp4">
          </video>
          </div>
        </figure>

        <p>
        <a href="#" videoId="video_arr_print" class="timestamp" start="0:00" end="0:20"></a><br>
        Once again, we call our method with a couple examples, in order to ensure that we have enough contexts in which we can develop our algorithm.
        </p>

        <p>
        <a href="#" videoId="video_arr_print" class="timestamp" start="0:20" end="1:00"></a><br>
        Writing the implementation continues in much the same manner as the last example. We know we want to show each element of the array, so we loop. Because we can see multiple iterations of the loop, we can see how the loop body builds up a solution.
        </p>

        <p>
        <a href="#" videoId="video_arr_print" class="timestamp" start="1:00" end="1:41"></a><br>
        Here, we take advantage of the liveness of the environment to experiment with different ways to insert commas to separate each element. Putting a comma before every element does not work, so we only append a comma if we are not handling the first element in the array.
        </p>

        <p>
        <a href="#" videoId="video_arr_print" class="timestamp" start="1:41" end="1:51"></a><br>
        Finally, we inspect the other call to make sure that the method executes as expected.
        </p>

      </section>
      <section>
        <h2><span class="sectionNumber"></span>Ongoing and Future Work</h2>
      </section>
      <section>
        <h2><span class="sectionNumber"></span>Conclusion</h2>
      </section>
      <section id="references">
        <h2>References</h2>

        <ol class="fullwidth">
        <li> Brendan Gregg. <em>Flame Graphs</em>. Retrieved from <a target="_blank" href="http://www.brendangregg.com/flamegraphs.html">http://www.brendangregg.com/flamegraphs.html</a>
        </li>
        <li>
          J. B. Kruskal and J. M. Landwehr. 1983. <em>Icicle Plots: Better Displays for Hierarchical Clustering</em>. The American Statistician 37, 2 (1983), 162–168. DOI:<a target="_blank" href="https://doi.org/10.2307/2685881">https://doi.org/10.2307/2685881</a>
        </li>
        <li>
          Bret Victor. 2012. <em>Inventing on Principle</em>. Retrieved from <a target="_blank" href="https://vimeo.com/36579366">https://vimeo.com/36579366</a>
        </li>
        <li>
          Bret Victor. 2012. <em>Learnable Programming</em>. Retrieved from <a target="_blank" href="http://worrydream.com/LearnableProgramming/">http://worrydream.com/LearnableProgramming/</a>
        </li>
        </ol>

      </section>
    </article>

    <!-- 3rd-party stuff -->
    <script src="seymour-interpreter/3rdparty/ohm.min.js"></script>
    <script src="seymour-interpreter/3rdparty/jquery-3.2.1.min.js"></script>
    <script src="seymour-interpreter/3rdparty/codemirror.js"></script>
    <script src="seymour-interpreter/3rdparty/checked-emitter.js"></script>
    <script src="seymour-interpreter/3rdparty/underscore.js"></script>
    <link rel="stylesheet" href="seymour-interpreter/3rdparty/codemirror.css">

    <!-- Language ----------------------------------->

    <!-- the interpreter -->
    <script src="seymour-interpreter/lang/activations.js"></script>
    <script src="seymour-interpreter/lang/asts.js"></script>
    <script src="seymour-interpreter/lang/builtins.js"></script>
    <script src="seymour-interpreter/lang/instructions.js"></script>
    <script src="seymour-interpreter/lang/Interpreter.js"></script>
    <script src="seymour-interpreter/lang/Method.js"></script>
    <script src="seymour-interpreter/lang/Obj.js"></script>
    <script src="seymour-interpreter/lang/BlockClosure.js"></script>
    <script src="seymour-interpreter/lang/Class.js"></script>
    <script src="seymour-interpreter/lang/SourceLoc.js"></script>

    <!-- syntax stuff -->
    <script src="seymour-interpreter/lang/grammar.js"></script>
    <script src="seymour-interpreter/lang/parse.js"></script>
    <script src="seymour-interpreter/lang/syntaxHighlight.js"></script>
    <link rel="stylesheet" href="seymour-interpreter/syntaxHighlight.css">

    <!-- prelude -->
    <script src="seymour-interpreter/lang/prelude.js"></script>

    <!-- Visualizations---------------------------->

    <script src="seymour-interpreter/viz/Env.js"></script>
    <script src="seymour-interpreter/viz/EventRecorder.js"></script>
    <script src="seymour-interpreter/viz/MicroVizEvents.js"></script>
    <script src="seymour-interpreter/viz/macroViz.js"></script>
    <script src="seymour-interpreter/viz/microViz.js"></script>
    <script src="seymour-interpreter/viz/events.js"></script>
    <link rel="stylesheet" href="seymour-interpreter/viz/microViz.css">
    <link rel="stylesheet" href="seymour-interpreter/viz/macroViz.css">

    <!-- pulling it all together -->

    <link rel="stylesheet" href="seymour-interpreter/seymour.css"> 
    <link rel="stylesheet" href="seymour-interpreter/highlighting.css">

    <script src="seymour-interpreter/lib.js"></script>
    <!-- <script src="seymour-interpreter/setup.js"></script> -->
    <script src="seymour-interpreter/highlighting.js"></script>
    <script src="seymour-interpreter/pathmatcher.js"></script>
    <script src="seymour-interpreter/seymour.js"></script>
    <script src="index.js"></script>
  </body>
</html>
