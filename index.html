<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>Seymour - Insert Pithy Title Here</title>
    <link rel="stylesheet" href="tufte.css"/>
    <link rel="stylesheet" href="latex.css"/>
    <link rel="stylesheet" href="style.css"/>
    <meta name="viewport" content="width=device-width, initial-scale=1">
  </head>

  <body>
    <article>
      <h1 id="title">Seymour - Insert Pithy Title Here</h1>
      <p class="subtitle">Saketh Kasibatla and Alex Warth<br>
      HARC/Y Combinator Research</p>

      <section id="abstract">
        <blockquote><b>abstract goes here.</b> This project involves discovering how the American Revolution was remembered during the nineteenth century.  The goal is to show that the American Revolution was memorialized by the actions of the United States government during the 1800s. This has been done by examining events such as the Supreme Court cases of John Marshall and the Nullification Crisis. Upon examination of these events, it becomes clear that John Marshall and John Calhoun (creator of the Doctrine of Nullification) attempted to use the American Revolution to bolster their claims by citing speeches from Founding Fathers. Through showing that the American Revolution lives on in memory, this research highlights the importance of the revolution in shaping the actions of the United States government.</blockquote>
      </section>
      <section>
        <h2><span class="sectionNumber"></span> Introduction</h2>
      </section>
      <section>
        <h2><span class="sectionNumber"></span> Related Work</h2>
      </section>
      <section>
        <h2><span class="sectionNumber"></span> The Programming Environment</h2>
        <p>
        Seymour’s programming environment consists of three different components, as shown in the screenshot below:
        </p>

        <figure id="screenshot1">
          <img class="block light-bg-protect" src="media/screenshot1.png"></img>
        </figure>

        <p>
        These are:
        </p>

        <ul>
          <li>the code editor (top left)</li>
          <li>the micro view, which can visualize any scope in detail </li>
          <li>the macro view, which serves as an overview of the whole program </li>
        </ul>

        <p>
        Together, these components help the user see and build a model of the inner workings of the program.
        </p>

        <h3>The Micro Visualization</h3>
        <p>The micro visualization focuses on telling the user a coherent story about the low level details of a program. 
        </p>

        <p>
        We show effects next to the lines that produce them, and changing the code for an effect changes the visualization live..
        </p>

        <figure id="video1" class="fullwidth">
          <video class="block light-bg-protect" width="960" height="65" 
              preload="auto" controls="" muted="" data-video="0">
            <!-- poster="./media/seymour.poster.png" -->
            <source src="./media/micro_viz_example/1.mp4" type="video/mp4">
          </video>
        </figure>

        <!-- <figure id="env1">
          <label for="mn-change-code" class="margin-toggle">⊕</label><input type="checkbox" id="mn-change-code" class="margin-toggle"><span class="marginnote">the detail visualization updates when the code is edited</span>
          <div id="microVizContainer1"></div>
          <div id="errorDiv1"></div>
        </figure>  -->

        <p>
        Changes to program state are rendered next to the line where they happen, making it easy to connect the code and the micro visualization. We also render a blue dot for each subexpression in the program, allowing the user to see how a value was built up. Users can hover over these dots to see the value the corresponding subexpression returns.
        </p>

        <figure id="video2" class="fullwidth">
          <video class="block light-bg-protect" width="960" height="107" 
              preload="auto" controls="" muted="" data-video="0">
            <!-- poster="./media/seymour.poster.png" -->
            <source src="./media/micro_viz_example/2.mp4" type="video/mp4">
          </video>
        </figure>

        <p>We show loops using several columns. Each column represents an iteration of the loop.</p>

        <figure id="video3" class="fullwidth">
          <video class="block light-bg-protect" width="960" height="109.5" 
              preload="auto" controls="" muted="" data-video="0">
            <!-- poster="./media/seymour.poster.png" -->
            <source src="./media/micro_viz_example/3.mp4" type="video/mp4">
          </video>
        </figure>

        <p>
        The user can read through a single row to see how a values change over time, or they can read through a column to see what happened in a particular iteration.
        </p>

        <figure id="video4" class="fullwidth">
          <video class="block light-bg-protect" width="960" height="132.5" 
              preload="auto" controls="" muted="" data-video="0">
            <!-- poster="./media/seymour.poster.png" -->
            <source src="./media/micro_viz_example/4.mp4" type="video/mp4">
          </video>
        </figure>

        <p>
        Because we only show effect for code that is executed, it is easy to ‘follow the flow’* of the program over time.
        </p>

        <figure id="video5" class="fullwidth">
          <video class="block light-bg-protect" width="960" height="170.5" 
              preload="auto" controls="" muted="" data-video="0">
            <!-- poster="./media/seymour.poster.png" -->
            <source src="./media/micro_viz_example/5.mp4" type="video/mp4">
          </video>
        </figure>

        <!-- <figure id="env2">
          <label for="mn-hover" class="margin-toggle">⊕</label><input type="checkbox" id="mn-hover" class="margin-toggle"><span class="marginnote">hovering over message sends (e.g. the loop, blue dots) highlights the code that produced them and shows their return value</span>
          <div id="microVizContainer2"></div>
          <div id="errorDiv2"></div>
        </figure>  -->

        <p>In addition to built in loop constructs, programmers often rely on control structures implemented in the language (e.g. map, filter, reduce). To the best of our knowledge, when working with these control structures, other similar visualizations do not support rendering these structures in the same manner as loops. Our visualization can detect and show ‘loopy’ code using multiple columns. This allows us to render many control structures, including those defined by the user, automatically.
        </p>
        
        <p>FIGURES FOR REDUCE AND DO WHILE GO HERE</p>

        <p>
        While creating the micro visualization, we sought to help the user avoid simulating the program in their head. We show every state change, without interaction, so that the user does not have to simulate the program to select a portion of the state to show.
        </p>

        <p>
        When a method is called, in addition to producing a result, it can modify the program’s state. If these side effects are not shown, the user must fall back to mentally simulating the program. Consider the program below:
        </p>

        <figure id="summary">
          <label for="mn-emoji" class="margin-toggle">⊕</label><input type="checkbox" id="mn-emoji" class="margin-toggle"><span class="marginnote">We use emoji to identify different objects, instead of memory addresses or object IDs.</span>
          <img class="block light-bg-protect" src="media/summary.png"></img>
        </figure>

        <p>
        Because the call to f is preceded by a statement that increments a, and followed by a statement that decrements it, the user might expect a to be 5 at the end of the program. If we do not show that f sets a to 7, the user must resort to reading f’s source to figure out why a is not 5 at the end of the program. But, because we do show f’s side effects, at a glance, the user can confirm that a = 6 because f set a to 7 before it was decremented.
        </p>

        <p>
        For each message send, we summarize all side effects that are relevant to the execution after the send has completed. We show the last value of variables that are written multiple times, and hide the values of local variables that do not affect computation past the duration of the message send.
        </p>

        <figure id="summary-2">
          <img class="block light-bg-protect" src="media/summary-2.png"></img>
        </figure>

        <p>
        A message send's summary elides most of its implementation details in order to give the user 'just enough’ information to continue reading the story of the execution. But, if the user is interested in these details, we can show the story of any message send. In fact, we treat the program as a message send, and show its implementation details as we would those of any other message. For example, we can show the details of the call to add5 below.
        </p>

        <figure id="adder">
          <img class="block light-bg-protect" src="media/adder.png"></img>
        </figure>

        <p>
        When visualizing a message send, we also show all lexical scopes that the send has access to. Thus, all the information needed to calculate the send’s result is on screen, and the method only has access to the values it can ‘see’. In the program above, which visualizes the call to add5, we know the value of ‘this’ which the add5 call has access to at a glance.
        </p>

        <h3>The Macro Visualization</h3>

        <p>
        The micro view can visualize any single scope in the program. But, views of many different scopes are not enough to get a complete understanding of the program. Programmers need a low-level understanding of individual message sends, and a high level understanding of how these calls relate. Consider the following program:
        </p>

        <figure id="env6" class="fullwidth">
          <div id="microVizContainer6"></div>
          <div id="errorDiv6"></div>
          <div id="macroVizScroller6">
            <div id="macroVizContainer6"></div>
          </div>
        </figure>

        <p>
        The overview visualization shows the ‘big picture’ of the computation. It displays the structure of the program’s message sends while hiding the particular details of what occurred in each send. Because it shows information about the whole program, it is a useful complement to the detail view, helping the user relate the story of a particular scope to the larger program execution. It also serves as a UI element with which the user can select a scope to ‘focus’ on in the detail view.
        </p>

        <p>
        This visualization is inspired by <span>icicle plots<label for="icicle" class="margin-toggle sidenote-number"></label></span></span><input type="checkbox" id="icicle" class="margin-toggle"><span class="sidenote"><a href="http://dx.doi.org/10.2307/2685881" target="_blank">Kruskal and Landwehr. <em>Icicle Plots</em></a></span> and <span>flame graphs<label for="flame" class="margin-toggle sidenote-number"></label></span><input type="checkbox" id="flame" class="margin-toggle"><span class="sidenote"><a href="http://www.brendangregg.com/flamegraphs.html" target="_blank">Brendan Gregg. <em>Flame Graphs</em></a></span>, which are commonly used in program profilers. Each message send is drawn as a rectangular node on screen, and the caller-callee relationships between sends are shown using the tree structure of the visualization. All calls that are made in a particular message send are drawn below its node in the visualization. Sends that do not make any calls have fixed width, and all other sends are wide enough to contain all their children. 
        </p>

        <p>
        The visualization’s regular structure allows the user to see the ‘shape’ of the computation. Wider nodes contain more sends, and generally make up more of the program execution, while deeper subtrees indicate greater stack depth. Similar call patterns are drawn as similar shapes on screen, and can be used as landmarks in the larger visualization. For example, in the figure above, the repeated shape of the call to ‘Number.fact()’ tells the user that there is some repeated computation going on, and the change in depth of each call indicates how the computation changes with each loop.
        </p>
      </section>
      <section>
        <h2><span class="sectionNumber"></span>Programming with Seymour</h2>
        <p>
        In this section, we will give the reader a feel for Seymour’s live editing experience.  Using several examples, we will show how the macro view, the micro view, and the ‘focus’ mechanic come together to let the user see the internals of a program as they write it.
        </p>

        <p>
        Each example consists of a video followed by commentary. Click the timestamp at the top of each paragraph to view the relevant portion of the video.
        </p>

        <h3>Number.fibonacci()</h3>

        <p>
        In the previous section, we saw how a user might interact with a fully written implementation of factorial. Here, we show how a user might write the same program, with Seymour’s help. 
        </p>

        <figure id="video_fib" class="fullwidth">
          <video class="block light-bg-protect" width="960" height="431.5" 
              preload="auto" controls="" muted="" data-video="0">
            <!-- poster="./media/seymour.poster.png" -->
            <source src="./media/fib.mp4" type="video/mp4">
          </video>
        </figure>

        <p>
        <a href="#" videoId="video_fib" class="timestamp" start="0:00" end="0:21"></a><br>
        The user starts by writing an empty method declaration and several calls to fibonacci. Each of these calls can be used as a concrete context in which the user can experiment with the algorithm. Because the user can only take advantage of the micro visualization when they have a call to focus on, they are encouraged to consider different examples that might be helpful in developing an algorithm.
        </p>

        <p>
        <a href="#" videoId="video_fib" class="timestamp" start="0:21" end="0:39"></a><br>
        The user focuses on 1.fibonacci(), and writes the algorithm’s base case. The micro visualization serves as a steady frame, showing method behaviour as the code changes. We persist the focused call across different program executions, so that the user does not have to repeatedly focus the same call, in order to see the method behaves as the code changes. 
        </p>

        <p>
        <a href="#" videoId="video_fib" class="timestamp" start="0:39" end="1:13"></a><br>
        They finish up by writing the recursive case. We can see the recursive structure of fibonacci emerge in the macro visualization, and the loop shows the correct answers for each call.
        </p>

        <h3>Array.print()</h3>

        <figure id="video_arr_print" class="fullwidth">
          <video class="block light-bg-protect" width="960" height="363" 
              preload="auto" controls="" muted="" data-video="0">
            <!-- poster="./media/seymour.poster.png" -->
            <source src="./media/array_print/array_print.mp4" type="video/mp4">
          </video>
        </figure>


      </section>
      <section>
        <h2><span class="sectionNumber"></span>Ongoing and Future Work</h2>
      </section>
      <section>
        <h2><span class="sectionNumber"></span>Conclusion</h2>
      </section>
      <section>
        <h2><span class="sectionNumber"></span>Appendix: The Seymour Programming Language</h2>
      </section>
      <section id="references">
        <h2>References</h2>

        <ol class="fullwidth">
        <li> Brendan Gregg. <em>Flame Graphs</em>. Retrieved from <a target="_blank" href="http://www.brendangregg.com/flamegraphs.html">http://www.brendangregg.com/flamegraphs.html</a>
        </li>
        <li>
          J. B. Kruskal and J. M. Landwehr. 1983. <em>Icicle Plots: Better Displays for Hierarchical Clustering</em>. The American Statistician 37, 2 (1983), 162–168. DOI:<a target="_blank" href="https://doi.org/10.2307/2685881">https://doi.org/10.2307/2685881</a>
        </li>
        <li>
          Bret Victor. 2012. <em>Inventing on Principle</em>. Retrieved from <a target="_blank" href="https://vimeo.com/36579366">https://vimeo.com/36579366</a>
        </li>
        <li>
          Bret Victor. 2012. <em>Learnable Programming</em>. Retrieved from <a target="_blank" href="http://worrydream.com/LearnableProgramming/">http://worrydream.com/LearnableProgramming/</a>
        </li>
        </ol>

      </section>
    </article>

    <!-- 3rd-party stuff -->
    <script src="seymour-interpreter/3rdparty/ohm.min.js"></script>
    <script src="seymour-interpreter/3rdparty/jquery-3.2.1.min.js"></script>
    <script src="seymour-interpreter/3rdparty/codemirror.js"></script>
    <script src="seymour-interpreter/3rdparty/checked-emitter.js"></script>
    <script src="seymour-interpreter/3rdparty/underscore.js"></script>
    <link rel="stylesheet" href="seymour-interpreter/3rdparty/codemirror.css">

    <!-- Language ----------------------------------->

    <!-- the interpreter -->
    <script src="seymour-interpreter/lang/activations.js"></script>
    <script src="seymour-interpreter/lang/asts.js"></script>
    <script src="seymour-interpreter/lang/builtins.js"></script>
    <script src="seymour-interpreter/lang/instructions.js"></script>
    <script src="seymour-interpreter/lang/Interpreter.js"></script>
    <script src="seymour-interpreter/lang/Method.js"></script>
    <script src="seymour-interpreter/lang/Obj.js"></script>
    <script src="seymour-interpreter/lang/BlockClosure.js"></script>
    <script src="seymour-interpreter/lang/Class.js"></script>
    <script src="seymour-interpreter/lang/SourceLoc.js"></script>

    <!-- syntax stuff -->
    <script src="seymour-interpreter/lang/grammar.js"></script>
    <script src="seymour-interpreter/lang/parse.js"></script>
    <script src="seymour-interpreter/lang/syntaxHighlight.js"></script>
    <link rel="stylesheet" href="seymour-interpreter/syntaxHighlight.css">

    <!-- prelude -->
    <script src="seymour-interpreter/lang/prelude.js"></script>

    <!-- Visualizations---------------------------->

    <script src="seymour-interpreter/viz/Env.js"></script>
    <script src="seymour-interpreter/viz/EventRecorder.js"></script>
    <script src="seymour-interpreter/viz/MicroVizEvents.js"></script>
    <script src="seymour-interpreter/viz/macroViz.js"></script>
    <script src="seymour-interpreter/viz/microViz.js"></script>
    <script src="seymour-interpreter/viz/events.js"></script>
    <link rel="stylesheet" href="seymour-interpreter/viz/microViz.css">
    <link rel="stylesheet" href="seymour-interpreter/viz/macroViz.css">

    <!-- pulling it all together -->

    <link rel="stylesheet" href="seymour-interpreter/seymour.css"> 
    <link rel="stylesheet" href="seymour-interpreter/highlighting.css">

    <script src="seymour-interpreter/lib.js"></script>
    <!-- <script src="seymour-interpreter/setup.js"></script> -->
    <script src="seymour-interpreter/highlighting.js"></script>
    <script src="seymour-interpreter/pathmatcher.js"></script>
    <script src="seymour-interpreter/seymour.js"></script>
    <script src="index.js"></script>
  </body>
</html>
