<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>Seymour: Live Programming with Details and the Big Picture</title>
    <link rel="stylesheet" href="tufte.css"/>
    <link rel="stylesheet" href="latex.css"/>
    <link rel="stylesheet" href="style.css"/>
    <meta name="viewport" content="width=device-width, initial-scale=1">
  </head>

  <body>
    <article>
      <h1 id="title">Seymour: Live Programming with Details and the Big Picture</h1>
      <p class="subtitle">Saketh Kasibatla and Alex Warth<br>
      HARC/Y Combinator Research</p>

      <section id="abstract">
        <blockquote><b>TODO: abstract goes here.</b>
      </section>
      <section>
        <h2><span class="sectionNumber"></span>Introduction</h2>
        <p>
        The live programming community has produced many inspiring visions of programming. Chris… steady frame, adjusting rather than aiming. Bret ... immediate connection between creator and creation. Seeing immediate effects, also nothing hidden . Sean … .
        </p>

        <p>
        But, even after fifteen years of work in this space, we are yet to see these ideas significantly impact how we program today. We believe there are significant design and engineering problems that stand in the way of creating novel programming experiences fit for widespread adoption. It may be that it is too difficult to make such an experience scale to the needs of programmers at large in one shot. We need a better strategy for making progress towards this goal.
        </p>

        <p>
        One such strategy is to solve a smaller version of the problem and adapt some of the techniques we develop to a broader solution. We have begun developing an environment that aims to provide a better programming experience for an introduction to programming course. There are several advantages that this use case affords us.
        </p>

        <p>
        First, the size and complexity of the programs students write is far smaller than those written for commercial purposes. They are also implied by the class curriculum, homework assignments, and projects, all of which the teacher has some control over. This allows us to design experiences without being constrained by scalability[design, efficiency]. Furthermore, because the teacher controls class assignments, we can build custom, domain specific experiences for each assignment, instead of attempting to create a fully general experience. Even if we never manage to make this PX scale to be useful in the world, this project has the potential to make programming much more accessible and help students overcome the steep learning curve of programming.
        </p>

        <p>
        This paper presents Seymour, a very early prototype of our first attempts to follow this strategy. The goal of Seymour is to help beginners develop an intuition for program semantics, and to encourage experimentation. We do this by providing a visualization of the execution of a program, live rendered as the student writes it. Students and teachers spend significant time simulating the behaviour of a program(mentally, or on paper), often erroneously. We believe that automating the creation of visual explanations of these programs will significantly ease the mental burden on teachers and students alike. (transition from drawn sims to autogenerated sims) (insert reference to guo here)
        </p>

        <p>The technical contributions of this paper are</p>

        <ul>
          <li>A multiple views visualization[?] (https://dl.acm.org/citation.cfm?id=345271) of program execution with two parts
            <ul>
              <li>A micro visualization, based on a demo from Inventing on Principle [?] with additions to support arbitary control structures and message sends</li>
              <li>A macro visualization, which relates the micro visualization to the rest of the program's execution</li>
            </ul>
          </li>
        </ul>

        <p>
        The programming environment we describe here has not been user tested. But, we intend to pilot it in classrooms this fall.
        </p>

        <p>
        Structure sentence (might wanna skip this)
        </p>
      </section>
      <section>
        <h2><span class="sectionNumber"></span>The Programming Environment</h2>
        <p>
        Seymour’s programming environment consists of three different components, as shown in the screenshot below:
        </p>

        <figure id="screenshot1">
          <img class="block light-bg-protect" src="media/screenshot1.png"></img>
        </figure>

        <p>
        These are:
        </p>


        <ul>
          <li>the code editor (top left),</li>
          <li>the <em>micro visualization</em> (top right), which provides details about the activation of a method or function, and</li>
          <li>the <em>macro visualization</em> (bottom), which provides an overview of the entire program's execution.</li>
        </ul>

        <p>
        Together, these components help the programmer see and understand the dynamic behavior of their code, even while they're writing it.
        </p>

        <h3>The Micro Visualization</h3>
        <p>
          The micro visualization displays details about the execution of the code. These details are shown next to the lines of code that
          produced them, and they are updated as the programmer makes changes to the code.
        </p>

        <figure id="video1" class="fullwidth">
          <div class="video-mask">
          <video class="block light-bg-protect" width="960" height="65"
              poster="./media/micro_viz_example/1.poster.png"
              preload="auto" muted="" data-video="0">
            <source src="./media/micro_viz_example/1.mp4" type="video/mp4">
          </video>
          </div>
        </figure>

        <!-- <figure id="env1">
          <label for="mn-change-code" class="margin-toggle"></label><input type="checkbox" id="mn-change-code" class="margin-toggle"><span class="marginnote">the detail visualization updates when the code is edited</span>
          <div id="microVizContainer1"></div>
          <div id="errorDiv1"></div>
        </figure>  -->

        <p>
          Each subexpression in the program is rendered as a blue dot. To see the value of a subexpression, the programmer simply hovers over its corresponding blue
          dot.
        </p>

        <figure id="video2" class="fullwidth">
          <div class="video-mask">
          <video class="block light-bg-protect" width="960" height="107"
              poster="./media/micro_viz_example/2.poster.png"
              preload="auto" muted="" data-video="0">
            <source src="./media/micro_viz_example/2.mp4" type="video/mp4">
          </video>
          </div>
        </figure>

        <p>
          Seymour's micro visualization displays loops using a columnar format. Each column represents an iteration of the loop. The programmer can read through a single
          row to see how a variable changes over time, or they can read through a column to see what happened in a particular iteration.
        </p>

        <figure id="video4" class="fullwidth">
          <div class="video-mask">
          <video class="block light-bg-protect" width="960" height="132.5"
              poster="./media/micro_viz_example/4.poster.png"
              preload="auto" muted="" data-video="0">
            <source src="./media/micro_viz_example/4a.mp4" type="video/mp4">
          </video>
          </div>
        </figure>

        <p>
        Because Seymour only shows effects for code that is executed, it is easy to <span>&ldquo;follow the flow&rdquo;<label for="mn-learnable" class="margin-toggle"></label></span>
        <input type="checkbox" id="mn-learnable" class="margin-toggle"><span class="marginnote">
          <a href="http://worrydream.com/LearnableProgramming/">Bret Victor. &ldquo;Learnable Programming&rdquo;</a>
        </span>
        of the program over time.
        </p>

        <figure id="video5" class="fullwidth">
          <div class="video-mask">
          <video class="block light-bg-protect" width="960" height="170.5"
              poster="./media/micro_viz_example/5.poster.png"
              preload="auto" muted="" data-video="0">
            <source src="./media/micro_viz_example/5.mp4" type="video/mp4">
          </video>
          </div>
        </figure>

        <!-- <figure id="env2">
          <label for="mn-hover" class="margin-toggle"></label><input type="checkbox" id="mn-hover" class="margin-toggle"><span class="marginnote">hovering over message sends (e.g. the loop, blue dots) highlights the code that produced them and shows their return value</span>
          <div id="microVizContainer2"></div>
          <div id="errorDiv2"></div>
        </figure>  -->

        <p>
          In addition to built-in loop constructs, programmers often rely on user-defined control structures, e.g. <code>map</code>, <code>filter</code>, and
          <code>reduce</code>. While these are not loops in the strict sense of the word, they are "loop-like" and the programmer would benefit from being
          able to visualize them as such. Seymour automatically detects <i>loopy</i> behavior and provides a columnar visualization for it, as shown below. In fact,
          all of the built-in control structures in Seymour's language are simply message sends / method calls (as in Smalltalk) and they are rendered
          in a columnar manner using the same mechanism&mdash;i.e., there is no special handling for built-in control structures.
        </p>

        <figure id="reduce">
          <label for="mn-emoji" class="margin-toggle no-star"></label><input type="checkbox" id="mn-emoji" class="margin-toggle"><span class="marginnote">We use emoji to identify different objects, instead of memory addresses or object IDs.</span>
          <img class="block light-bg-protect" src="media/reduce.png"></img>
        </figure>

        <p>
          Note that the call to <code>reduce()</code> is rendered as a loop, even though its implementation is recursive. A detailed description of our mechanism for detecting loopiness and Seymour's micro visualization will be the subject of
          an upcoming paper.
        </p>
        <p>
        While creating the micro visualization, we sought to help the user avoid simulating the program in their head. We show every state change, without interaction, so that the user does not have to simulate the program to select a portion of the state to show.
        </p>

        <p>
        When a method is called, in addition to producing a result, it can modify the program’s state. If these side effects are not shown, the user must fall back to mentally simulating the program. Consider the program below:
        </p>

        <figure id="summary">
          <img class="block light-bg-protect" src="media/summary.png"></img>
        </figure>

        <p>
        Because the call to <code>f()</code> is preceded by a statement that increments <code>a</code>, and followed by a statement that decrements it, the user might expect <code>a</code> to be 5 at the end of the program. If we do not show that <code>f()</code> sets <code>a</code> to 7, the user must resort to reading <code>f()</code>’s source to figure out why <code>a</code> is not 5 at the end of the program. But, because we do show <code>f()</code>’s side effects, at a glance, the user can confirm that <code>a = 6</code> because <code>f()</code> set <code>a</code> to 7 before it was decremented.
        </p>

        <p>
        For each message send, we summarize all side effects that are relevant to the execution after the send has completed. We show the last value of variables that are written multiple times, and hide the values of local variables that do not affect computation past the duration of the message send.
        </p>

        <figure id="summary-2">
          <img class="block light-bg-protect" src="media/summary-2.png"></img>
        </figure>

        <p>
        A message send's summary elides most of its implementation details in order to give the user 'just enough’ information to continue reading the story of the execution. But, if the user is interested in these details, we can show the story of any message send. In fact, we treat the program as a message send, and show its implementation details as we would those of any other message. For example, we can show the details of the call to <code>add5()</code> below.
        </p>

        <figure id="adder">
          <img class="block light-bg-protect" src="media/adder.png"></img>
        </figure>

        <p>
        When visualizing a message send, we also show all lexical scopes that the send has access to. Thus, all the information needed to calculate the send’s result is on screen, and the method only has access to the values it can ‘see’. In the program above, which visualizes the call to  <code>add5()</code>, we know the value of <code>this</code> which the  <code>add5()</code> call has access to at a glance.
        </p>

        <h3>The Macro Visualization</h3>

        <p>
        Seymour's micro visualization can visualize any single scope in the program. However, views of disconnected scopes are not enough to get a complete understanding of the program. Programmers need a low-level understanding of individual message sends, and a high level understanding of how these calls relate.
        </p>

        <p>
        The macro visualization helps the user build this high-level understanding by
        </p>

        <ul>
          <li>showing overall patterns in the program</li>
          <li>providing a user interface for ‘focusing’ the micro visualization on different scopes</li>
          <li>serving as a steady frame to which the micro visualization can be related</li>
        </ul>

        <figure id="screenshot_fib_1">
          <img class="block light-bg-protect" src="media/fib_macro_viz.png"></img>
        </figure>

        <p>
        The visualization is a variation on the <span>icicle plot<label for="icicle" class="margin-toggle"></label></span>
        <input type="checkbox" id="icicle" class="margin-toggle"><span class="marginnote">
          <a href="http://dx.doi.org/10.2307/2685881" target="_blank">Kruskal and Landwehr. &ldquo;Icicle Plots: Better Displays for Hierarchical Clustering&rdquo;</a>
        </span>
        —a method for visualizing hierarchical data that makes it easy to see the ‘shape’ of a computation. Each method call is drawn as a rectangular node on screen. Time progresses from left to right, with clusters of calls acting as landmarks on the program’s timeline. All calls that a method makes are drawn below its node in the visualization. Calls that do not make any further calls (leaf calls) have fixed width, and all other sends are wide enough to contain all their children; calls with more subcalls are wider than those with fewer subcalls.
        </p>

        <p>
        <span>Chrome DevTools<label for="chrome-dev-tools" class="margin-toggle"></label></span><input type="checkbox" id="chrome-dev-tools" class="margin-toggle">
        <span class="marginnote">
          <a href="https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/reference" target="_blank">Google Developers. &ldquo;Performance Analysis Reference&rdquo;</a><br><br>
          <a href="http://blog.librato.com/posts/chrome-devtools" target="_blank">Librato Blog. &ldquo;Timeline Profiling with Chrome DevTools&rdquo;</a>
        </span>
        uses a similar icicle plot to provide an overview of all the calls that occur in a profile. But, instead of giving leaf calls a fixed width, all calls are scaled based on their running time.
        </p>

        <p>
        The visualization also serves as an interactive element to navigate between various scopes in the micro visualization. When the user clicks on a node in the macro visualization, we ‘focus’ the micro visualization on the scope associated with that node. This makes it easy for the user to switch between contexts, drill down, and gather detailed information about the program.
        </p>

        <figure id="fib_focus" class="fullwidth">
          <div class="video-mask">
          <video class="block light-bg-protect" width="960" height="465.5"
              poster="./media/fib_focus.poster.png"
              preload="auto" muted="" data-video="0">
            <source src="./media/fib_focus.mp4" type="video/mp4">
          </video>
          </div>
        </figure>

        <p>
        The macro visualization does not change as we focus on different scopes, and it shows every call in the program. This makes it useful as a ‘steady frame’ for navigating the program. But, without further help from the system, it is difficult to connect the time-oriented macro visualization with the code-oriented micro visualization. We help the user make this connection using parallel highlighting. When the user hovers over a node in the macro visualization, we highlight the definition and call site of the call in question. Similarly, when the user hovers over a call in the code, we highlight all nodes in the macro visualization that correspond to that call.
        </p>

        <figure id="fib_highlighting" class="fullwidth">
          <div class="video-mask">
          <video class="block light-bg-protect" width="960" height="465.5"
              poster="./media/fib_highlighting.poster.png"
              preload="auto" muted="" data-video="0">
            <source src="./media/fib_highlighting.mp4" type="video/mp4">
          </video>
          </div>
        </figure>

      </section>
      <section>
        <h2><span class="sectionNumber"></span>Live Programming with Seymour</h2>
        <p>
        In this section, we will give the reader a feel for Seymour’s live programming experience.  Using several examples, we will show how the macro view, the micro view, and the ‘focus’ mechanic come together to let the user see the internals of a program as they write it.
        </p>

        <p>
        Each example consists of a video followed by commentary. Click the timestamp at the top of each paragraph to view the relevant portion of the video.
        </p>

        <h3>Number.fibonacci()</h3>

        <p>
        In the previous section, we saw how a user might interact with a fully written implementation of <code>Number.fibonacci()</code>. Here, we show how a we might implement the same program, with Seymour’s help.
        </p>

        <figure id="video_fib" class="fullwidth">
          <div class="video-mask">
          <video class="block light-bg-protect" width="960" height="431.5"
              poster="./media/fibonacci.poster.png"
              preload="auto" muted="" data-video="0">
            <source src="./media/fib.mp4" type="video/mp4">
          </video>
          </div>
        </figure>

        <p>
        <a href="#" videoId="video_fib" class="timestamp" start="0:00" end="0:21"></a><br>
        We start by writing an empty method declaration and several calls to fibonacci. Each of these calls can be used as a concrete context in which the user can experiment with the algorithm. Here, the micro visualization is used in a similar manner to the example view in <span>“Example Centric Programming.”<label for="example-centric-programming" class="margin-toggle"></label></span><input type="checkbox" id="example-centric-programming" class="margin-toggle">
        <span class="marginnote">
          <a href="http://dx.doi.org/10.1145/1052883.1052894" target="_blank">Jonathan Edwards. &ldquo;Example Centric Programming&rdquo;</a>
        </span> Because we can only take advantage of the micro visualization when there is a call for us to focus on, we are encouraged to consider a variety of examples that might help us understand different cases in the algorithm.
        </p>

        <p>
        <a href="#" videoId="video_fib" class="timestamp" start="0:21" end="0:39"></a><br>
        We focus on <code>1.fibonacci()</code>, and writes the algorithm’s base case. The micro visualization serves as a steady frame, showing method behavior as the code changes. As the user edits the method, and the program is re-executed, we <span>persistently focus on the same call<label for="managed-time" class="margin-toggle"></label></span><input type="checkbox" id="managed-time" class="margin-toggle"><span class="marginnote"><a href="http://dx.doi.org/10.1145/2661136.2661145" target="_blank">McDirmid and Edwards. &ldquo;Programming with Managed Time&rdquo;</a> @section 3</span>. This allows us to edit a method’s code without having to continually re-focus on the call of our choice.
        </p>

        <p>
        <a href="#" videoId="video_fib" class="timestamp" start="0:39" end="1:13"></a><br>
        We finish up by writing the recursive case. We can see the recursive structure of fibonacci emerge in the macro visualization, and the loop shows the correct answers for each call.
        </p>

        <h3>Array.toString()</h3>

        <p>
        In this example, we show how we can use Seymour to work with loops. We will implement <code>Array.toString()</code>, which must include the string representation of each of an array’s elements.
        </p>

        <figure id="video_arr_print" class="fullwidth">
          <div class="video-mask">
          <video class="block light-bg-protect" width="960" height="363"
              poster="./media/array_print.poster.png"
              preload="auto" muted="" data-video="0">
            <source src="./media/array_print/array_print.mp4" type="video/mp4">
          </video>
          </div>
        </figure>

        <p>
        <a href="#" videoId="video_arr_print" class="timestamp" start="0:00" end="0:20"></a><br>
        Once again, we call our method with a couple examples, in order to ensure that we have enough contexts in which we can develop our algorithm.
        </p>

        <p>
        <a href="#" videoId="video_arr_print" class="timestamp" start="0:20" end="1:00"></a><br>
        Writing the implementation continues in much the same manner as the last example. We know we want to show each element of the array, so we loop. Because we can see multiple iterations of the loop, we can see how the loop body builds up a solution.
        </p>

        <p>
        <a href="#" videoId="video_arr_print" class="timestamp" start="1:00" end="1:41"></a><br>
        Here, we take advantage of the liveness of the environment to experiment with different ways to insert commas to separate each element. Putting a comma before every element does not work, so we only append a comma if we are not handling the first element in the array.
        </p>

        <p>
        <a href="#" videoId="video_arr_print" class="timestamp" start="1:41" end="1:51"></a><br>
        Finally, we inspect the other call to make sure that the method executes as expected.
        </p>

      </section>
      <section>
        <h2><span class="sectionNumber"></span> Related Work</h2>

        <p>
        In
        <span>&ldquo;Inventing on Principle,&rdquo;<label for="rw-iop" class="margin-toggle"></label></span><input type="checkbox" id="rw-iop" class="margin-toggle"><span class="marginnote"><a href="https://vimeo.com/36579366#t=16m25s" target="_blank">Bret Victor. &ldquo;Inventing on Principle&rdquo;</a> @16:25</span> Victor introduced a novel visualization of program execution that has heavily influenced the design of Seymour's micro visualization.
        His visualization displays changes to program state over time, with each change lined up with the line of code that produced it.
        Our micro visualization builds on Victor's visualization and extends it with <em>call summaries</em>, which enable the programmer to see the side-effects that resulted from a call,
        at the call site. In Victor's visualization, this information is only available via local expansion (or inlining) of the call<label for="rw-iop2" class="margin-toggle"></label></span><input type="checkbox" id="rw-iop2" class="margin-toggle"><span class="marginnote"><a href="https://vimeo.com/62049081#t=1m41s" target="_blank">Bret Victor. &ldquo;Showreel 2011&ndash;2012&rdquo;</a> @1:41</span>&mdash;and because this requires interaction, these side effects (e.g., assignments to global variables) are easy to miss.
        </p>

        <p>
        <span>Light Table<label for="rw-lighttable" class="margin-toggle"></label></span><input type="checkbox" id="rw-lighttable" class="margin-toggle"><span class="marginnote"><a href="http://lighttable.com/" target="_blank">Chris Granger. &ldquo;Light Table&rdquo;</a></span> is an IDE that enables programmers to see dynamic (runtime) state inline with source code.
        It supports <em>watches</em>, which can be attached to expressions in the code to reveal their latest value as the program is executed. However, if a statement or expression is evaluated many times&mdash;e.g., as part of the body of a function that is called more than once&mdash;Light Table does not let the programmer select the context or activation that is associated with a watch.
        <span>YinYang<label for="rw-usable" class="margin-toggle"></label></span><input type="checkbox" id="rw-usable" class="margin-toggle"><span class="marginnote"><a href="http://dx.doi.org/10.1145/2509578.2509585" target="_blank">Sean McDirmid. &ldquo;Usable Live Programming&rdquo;</a></span> solves this problem with its <em>probes</em>, which also enable the programmer to view the values of expressions. Probes are similar to Light Table's watches, but they are associated with ‘print’ statements which generate log entries that are tied to the context in which they were created. By clicking on an item in the log, the programmer can see the probe values at the corresponding context. With Seymour, the programmer can see the details of any context by selecting it via the macro visualization. But unlike Light Table and YinYang, Seymour shows <em>all</em> of the side effects in the selected context automatically, minimizing the interaction required to see program state.
        </p>

        <p>
        <span>DejaVu is a domain-specific IDE extension for &ldquo;interactive camera-based programs&rdquo;<label for="rw-dejavu" class="margin-toggle"></label></span><input type="checkbox" id="rw-dejavu" class="margin-toggle"><span class="marginnote"><a href="http://dx.doi.org/10.1145/2380116.2380142" target="_blank">Kato et. al. &ldquo;DejaVu: integrated support for developing interactive camera-based programs&rdquo;</a></span>.
        It features a low-level canvas view that shows the values of variables at a ‘frame of interest’, and a high-level timeline view that shows variable values for many frames.
        These views complement each other in a similar manner to the micro and macro views in Seymour.
        But whereas DejaVu is designed specifically for the domain of camera-based programs and features visualizations tailored for displaying image data, Seymour’s visualizations are designed to explain the semantics of generic programs.
        <b>(TODO: say something here about future work, i.e., extending Seymour with a mechanism that enables programmers to develop program-specific visualizations? Maybe just add a forward-reference to Future work?)</b>
        </p>

        <p>
        <span>Online Python Tutor<label for="rw-pythontutor" class="margin-toggle"></label></span><input type="checkbox" id="rw-pythontutor" class="margin-toggle"><span class="marginnote">
          <a href="http://dx.doi.org/10.1145/2445196.2445368" target="_blank">Philip J. Guo. &ldquo;Online Python Tutor: Embeddable Web-Based Program Visualization for CS Education&rdquo;</a><br><br>
          <a href="http://pythontutor.com/live.html" target="_blank"> Philip J. Guo. &ldquo;Live Programming Mode - Python Tutor&rdquo;</a>
        </span>, a visualization tool for teaching beginner programmers, features a visualization that shows the entire program’s state at a single point in time.
        This includes the program counter, the stack, the heap, and relations between objects. Objects are drawn as boxes, and are connected by arrows, as a professor might depict them in a classroom.
        This type of visualization is complementary to those provided by Seymour, and we believe  programmers would benefit from seeing them together.
        </p>
      </section>
      <section>
        <h2><span class="sectionNumber"></span>Future Work</h2>
        <h3>Classroom Trials</h3>

        <p>
        We envision Seymour being used as a tool to assist students and professors in an intro to programming class. However, we have many improvements to make before Seymour is ready to be used in this context. We will be showing our environment in classrooms in the fall, in order to test it on students in a limited manner, and adjust our designs based on their feedback. We have access to an introduction to programming class, and a programming languages class at UCLA, where we will be using our environment to explain the semantics of Python.
        </p>

        <p>
        To support these trials, we plan to adapt Seymour to use Python as its underlying language. In order to simplify the process of changing the underlying language, we have developed a language agnostic library for creating the micro and macro visualizations, which can work with any imperative language. With this library, adapting Seymour to a new language becomes a matter of connecting the language’s runtime to the library. We will discuss this library in detail in an upcoming paper.
        </p>

        <h3>Better Support for Larger Programs</h3>

        <p>
        While Seymour’s visualizations work well for small programs, they become harder to use as programs grow in size. With larger programs, such as those students write for a class project, we have found that the micro visualization shows too many low level details, while the macro visualization shows too few. We are interested in improving Seymour’s visualizations to better explain these programs.
        </p>

        <p>
        The macro visualization can provide a global view of small programs. However, as program size grows, it becomes too large to read and understand. We are interested in using techniques such as <span>trace pruning<label for="mn-bohnet" class="margin-toggle"></label></span>
        <input type="checkbox" id="mn-bohnet" class="margin-toggle"><span class="marginnote">
          <a href="https://publishup.uni-potsdam.de/opus4-ubp/frontdoor/index/index/docId/32254" target="_blank">Johannes Bohnet. <em>Visualization of Execution Traces and its Application to Software Maintenance</em></a>
        </span>, fisheye, and minimaps to help the user process medium and large programs.
        </p>

        <p>
        We would also like to show more low level details in the macro visualization, in order to help users better understand where in their program to focus next. In a previous project (shown below), we visualized the execution of JavaScript methods, and let the user annotate the visualization based on low-level details (e.g. the value of a variable for a particular call).
        </p>

        <figure id="clarinet">
          <img class="block light-bg-protect" src="media/clarinet.png"></img>
        </figure>

        <p>
        In this example, which shows a parser generator, we can see characters being consumed (green), parse errors (red text), and calls where the parser backtracked (blue). To create an annotation, the user writes a query that selects the calls they want to annotate (e.g. calls that backtrack, calls that consume a character), and modifies their nodes’ appearance in the visualization. These modifications let the user read the macro visualization for high-level, program-specific patterns, instead of having to interact to find the information they are looking for.
        </p>

        <p>
        Another solution we are exploring is to make it easy to create domain specific visualizations from Seymour’s runtime data. These visualizations can display program information at the right level of abstraction to help the user understand the program. Instructors can use such a system to great effect, as visualizations can be reused as part of course materials, and can be shared with students as explanatory tools. Having computer-generated visualizations tied into the system also eases the tedious and error-prone process of drawing algorithms on the blackboard.
        </p>

        <p>
        Below is a screenshot of an initial attempt at visualizing dijkstra’s algorithm using events emitted by a running program. We use ‘timelines’ to show how a graph is traversed as the algorithm progresses. These visualizations are live, and update as the user changes the code.
        </p>

        <figure id="dijkstra">
          <img class="block light-bg-protect" src="media/dijkstra.png"></img>
        </figure>

        <h3>Language Features</h3>

        <p>Modular side effects, and maybe interventions here?</p>
      </section>
      <section>
        <h2><span class="sectionNumber"></span>Conclusion</h2>

        <p>
        We have shown Seymour—a live programming environment that visualizes program execution as the user types. Seymour features a micro visualization, which shows details of the program’s execution, and a macro visualization, which puts the micro visualization in context, and lets the user focus on different parts of the program execution. These visualizations come together to give the user a meaningful live programming experience.
        </p>

        <p>
        We are excited about the prospect of using this environment in the classroom and learning from student feedback. In doing so, we hope to make Seymour a valuable learning aid for students, and ultimately, create a better user experience for all programmers.
        </p>
      </section>

      <section>
        <h2>Acknowledgements</h2>

        <p>We would like to thank Sean McDirmid, Marko Röder, Aran Lunzer and Yoshiki Ohshima for their valuable feedback.</p>
      </section>
      <section id="references">
        <h2>References</h2>

        <ol class="fullwidth">
        <li> Brendan Gregg. <em>Flame Graphs</em>. Retrieved from <a target="_blank" href="http://www.brendangregg.com/flamegraphs.html">http://www.brendangregg.com/flamegraphs.html</a>
        </li>
        <li>
          J. B. Kruskal and J. M. Landwehr. 1983. <em>Icicle Plots: Better Displays for Hierarchical Clustering</em>. The American Statistician 37, 2 (1983), 162–168. DOI:<a target="_blank" href="https://doi.org/10.2307/2685881">https://doi.org/10.2307/2685881</a>
        </li>
        <li>
          Bret Victor. 2012. <em>Inventing on Principle</em>. Retrieved from <a target="_blank" href="https://vimeo.com/36579366">https://vimeo.com/36579366</a>
        </li>
        <li>
          Bret Victor. 2012. <em>Learnable Programming</em>. Retrieved from <a target="_blank" href="http://worrydream.com/LearnableProgramming/">http://worrydream.com/LearnableProgramming/</a>
        </li>
        </ol>

      </section>
    </article>

    <!-- 3rd-party stuff -->
    <script src="seymour-interpreter/3rdparty/ohm.min.js"></script>
    <script src="seymour-interpreter/3rdparty/jquery-3.2.1.min.js"></script>
    <script src="seymour-interpreter/3rdparty/codemirror.js"></script>
    <script src="seymour-interpreter/3rdparty/checked-emitter.js"></script>
    <script src="seymour-interpreter/3rdparty/underscore.js"></script>
    <link rel="stylesheet" href="seymour-interpreter/3rdparty/codemirror.css">

    <!-- Language ----------------------------------->

    <!-- the interpreter -->
    <script src="seymour-interpreter/lang/activations.js"></script>
    <script src="seymour-interpreter/lang/asts.js"></script>
    <script src="seymour-interpreter/lang/builtins.js"></script>
    <script src="seymour-interpreter/lang/instructions.js"></script>
    <script src="seymour-interpreter/lang/Interpreter.js"></script>
    <script src="seymour-interpreter/lang/Method.js"></script>
    <script src="seymour-interpreter/lang/Obj.js"></script>
    <script src="seymour-interpreter/lang/BlockClosure.js"></script>
    <script src="seymour-interpreter/lang/Class.js"></script>
    <script src="seymour-interpreter/lang/SourceLoc.js"></script>

    <!-- syntax stuff -->
    <script src="seymour-interpreter/lang/grammar.js"></script>
    <script src="seymour-interpreter/lang/parse.js"></script>
    <script src="seymour-interpreter/lang/syntaxHighlight.js"></script>
    <link rel="stylesheet" href="seymour-interpreter/syntaxHighlight.css">

    <!-- prelude -->
    <script src="seymour-interpreter/lang/prelude.js"></script>

    <!-- Visualizations---------------------------->

    <script src="seymour-interpreter/viz/Env.js"></script>
    <script src="seymour-interpreter/viz/EventRecorder.js"></script>
    <script src="seymour-interpreter/viz/MicroVizEvents.js"></script>
    <script src="seymour-interpreter/viz/macroViz.js"></script>
    <script src="seymour-interpreter/viz/microViz.js"></script>
    <script src="seymour-interpreter/viz/events.js"></script>
    <link rel="stylesheet" href="seymour-interpreter/viz/microViz.css">
    <link rel="stylesheet" href="seymour-interpreter/viz/macroViz.css">

    <!-- pulling it all together -->

    <link rel="stylesheet" href="seymour-interpreter/seymour.css">
    <link rel="stylesheet" href="seymour-interpreter/highlighting.css">

    <script src="seymour-interpreter/lib.js"></script>
    <!-- <script src="seymour-interpreter/setup.js"></script> -->
    <script src="seymour-interpreter/highlighting.js"></script>
    <script src="seymour-interpreter/pathmatcher.js"></script>
    <script src="seymour-interpreter/seymour.js"></script>
    <script src="index.js"></script>
  </body>
</html>
